---
title: '브라우저, DNS'
date: 2021-01-25 12:21:13
category: 'DNS'
draft: false
---

## 브라우저

사용자가 연결된 주소의 서버에 데이터 요청을 하게 되면 서버로부터 데이터를 다운받은 것을 가지고 웹브라우저가
그것을 해석해서 사용자가 보는 UI를 완성 해줍니다. 따라서 네트워크가 중요합니다.

### 브라우저의 기본 구조

1. 사용자 인터페이스
   주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분입니다.
2. 브라우저 엔진
   사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어합니다.
3. 렌더링 엔진
   요청한 콘텐츠를 표시. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시합니다.
4. 통신
   HTTP요청과 같은 네트워크 호출에 사용됩니다.
5. UI 백엔드
   콤보 박스와 창 같은 기본적인 장치를 그립니다. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용합니다.
6. 자바스크립트 해석기
   말 그대로 자바스크립트 코드를 해석하고 실행합니다.
7. 자료 저장소
   자료를 저장하는 계층입니다.

### 파싱 이란??

파싱이란 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것을 의미합니다.
파싱 결과는 보통 문서 구조를 나타내는 노드 트리인데 파싱 트리 또는 문법 트리라고 부릅니다.

### 파싱과 script 태그

자바스크립트인 script태그를 만나면 스크립트가 해석 및 실행되는 동안 문서의 파싱은 중단됩니다.
스크립트가 외부에 있는 경우 우선 네트워크로부터 자원을 가져와야 하는데 이 또한 실시간으로 처리되고 자원을 받을 때까지
파싱은 중단됩니다.
스타일 시트는 이론적으로 DOM트리를 변경하지 않기 때문에 문서 파싱을 기다리거나 중단하지 않습니다.
따라서 스크립트 파일을 먼저 로드하고 스크립트가 문서를 파싱하는 동안 스타일 정보를 요청하는 경우라면 문제가 생깁니다.
스크립트가 문서를 파싱하는동안 브라우저는 다른 작업을 수행하지 않기 때문에 스타일이 파싱되지 않은 상태가 되고 이렇게 된다면
레이아웃이 제대로 구성되지 않은 상태로 사용자에게 뷰를 제공할 확률이 높아져 사용자 경험을 떨어뜨리는 결과를 초래할 수 있습니다.
이러한 문제가 있기에 스크립트 소스를 body태그 끝에 두는 것을 권장합니다.

### 스크립트 로드 async, defer

body태그의 마지막에 스크립트 태그를 삽입하는 방식이 오래된 브라우저에서도 잘 작동하게 합니다.
다만 head 영역에 스크립트가 삽입되거나 외부의 파일에 정의되어 있다면 이벤트 연결은 문서의 로드시점에 맞게 처리해야 하는데
이 경우에 모던 브라우저에서는 defer,async속성을 사용할 수 있습니다.

- async 속성이 추가된 경우
  async 속성이 명시된 경우 브라우저가 페이지를 파싱하는 동안 스크립트가 실행됩니다. 즉 스크립트 파일이 비동기적으로 실행됩니다.
  HTML 구문 해석기가 스크립트 태그에 도달한 지점에서 스크립트를 실행하기 위해 파싱을 중단할 필요가 없습니다.
  따라서 HTML 구문 분석과 병행해서 스크립트를 가져온 후 스크립트가 준비가 될 때마다 즉시 실행이 가능해지는데,
  실행의 순서가 다운로드 완료 시점에 의해 결졍되므로 실행 순서가 중요한 스크립트들에 async를 사용할떄는 유의해야 합니다.

- defer 속성이 추가된 경우의 실행
  async 속성은 명시되어 있지 않고 defer 속성만 명시된 경우라면 브라우저가 페이지의 파싱을 모두 끝내면
  스크립트가 실행됩니다.
  비동기적으로 로드된 스크립트와 마찬가지로 HTML 구문 분석이 실행되는 동안 HTML해석을 방해하지 않고
  스크립트 파일을 다운로드 할 수 있습니다.
  async속성과의 차이점은 HTML 구문 분석이 완료되기 전에 스크립트 다운로드가 완료 되더라도
  구문 해석이 완료될 때까지 스크립트는 실행되지 않습니다.

### 렌더링 과정

1. 브라우저는 HTML, stylesheets를 해석합니다. 그리고 HTML 문서의 해석이 끝나면 DOM 트리를 만들고
   stylesheets 문서의 해석이 끝나면 스타일 규칙 CSSOM Tree을 만듭니다.
2. 만든 DOM 트리와 스타일 규칙을 합쳐 렌더 트리를 만듭니다. 여기에서 flow(배치)과정이 실행되어 각 요소들의 레이아웃을 위치시킵니다.
3. Layout 단계로 와서 브라우저의 뷰포트 내에서 각 노드들의 정확한 위치와 크기를 계산합니다.
   생성된 렌더트리 노드들이 가지고 있는 스타일과 속성에 따라서 브라우저 화면의 어느 위치에 어느 크기로 출력될지
   게산하는 단계입니다.
   뷰포트 크기가 달라질 경우 매번 계산을 다시합니다.
4. Layout 게산이 완료되면 Paint과정으로 요소들을 실제 화면에 그립니다.
   이전 단계에서 이미 요소들의 위치, 크기, 스타일 계싼이 완료된 렌더트리를 이용해 실제 픽셀 값을 채워넣습니다.
   이 과정에서 텍스트, 색, 이미지, 그림자 효과등이 처리되어 그려지는데, 처리해야 하는 스타일이 복잡할수록 Paint 단계에
   소요되는 시간이 늘어납니다.

### Reflow

렌더링 과정을 거친 뒤 최종적으로 페이지가 그려진다고 해서 끝나는것이 아닙니다.
특정 액션이나 이벤트에 따라 html요소의 크기나 위치, 레이아웃 등을 수정하면 그에 영향을 받는 자식이나 부모들을
포함하여 위에서 설명한 Layout 과정을 다시 수행합니다.
그러면 렌더트리와 각 요소들의 크기 및 위치를 다시 계산하는데 이 과정을 Reflow라고 합니다.

#### Reflow가 일어나는 예시

- 페이지 초기 렌더링 시
- 윈도우 리사이징 시 (뷰포트 크기 변화)
- 노드 추가 또는 제거
- 요소의 위치, 크기 변경(top, left, margin, padding, border, width 등)
- 폰트 변경과 이미지 크기 변경

```js
const reflowEvent = () => {
  document.getElementById('box').stlye.width = '500px'
}
```
